\documentclass[12pt,a4paper,titlepage]{article}
\usepackage[utf8]{inputenc}
\usepackage{fullpage}
\usepackage[english]{babel}
\usepackage{graphicx}
\usepackage{float}
\usepackage[toc,page]{appendix}
\usepackage[labelfont=bf,font=small]{caption}

% Figure numbering
\usepackage{chngcntr}
\counterwithin{figure}{section}
\counterwithin{table}{section}

% Line spacing
\usepackage{setspace}
%\onehalfspacing
\doublespacing

% Title page
\usepackage{pdfpages}

% Color
\usepackage{color}
\definecolor{bluekeywords}{rgb}{0.13,0.13,1}
\definecolor{greencomments}{rgb}{0,0.5,0}
\definecolor{redstrings}{rgb}{0.9,0,0}

% Code listings
\usepackage{listings}
\lstset{language=C++,
  showspaces=false,
  showtabs=false,
  breaklines=true,
  showstringspaces=false,
  breakatwhitespace=true,
  escapeinside={(*@}{@*)},
  commentstyle=\color{greencomments},
  keywordstyle=\color{bluekeywords},
  stringstyle=\color{redstrings},
  basicstyle=\ttfamily\scriptsize,
  tabsize=4,
  numbers=left,
  stepnumber=1,    
  firstnumber=1,
  numberfirstline=true,
  frame=tlrb
}

% Inline code
\definecolor{codegray}{gray}{0.3}
\newcommand{\code}[1]{\indent \colorbox{codegray}{\texttt{#1}}}

\begin{document}
\includepdf{reportTitlePage}

% Abstract
\begin{abstract}
This is the abstract.
\end{abstract}

% Table of contents
\tableofcontents

\newpage

% List of Tables
\listoftables

\newpage

% List of figures
\listoffigures

\newpage

\section{Introduction}
\textbf{This section should contain general information on the project and the technology used.}\\

Artificial Intelligence in games is becoming more and more popular due to new advancements in technology and increasing hardware resources on user devices. Running complex AI on users machines can sometimes be infeasible as the necessary CPU time or speed is just not available. Games are very CPU intensive applications that utilize a systems hardware for graphics rendering, audio output, networking, user inputs, and feedback. Artificial Intelligence can sometimes demand alot of processing in order to accurately generate realistic behaviours that can mimic sentient entities in a game. The type of algorithm needed for a particular behaviour in a game comes down to the knowledge and skill of the developer. This however means that highly skilled developers may attempt to implement a very complex and efficient ai algorithm when it may not be needed at all, and sometimes can produce inferior results compared to a simple animation or pre-defined behaviour. Choosing whether to use an algorithm to generate artificial intelligence or to simply pre-define a behaviour can be very difficult and could result in huge amounts of time and resources being wasted in a feeble attempt to create SkyNet\cite{skynet}. 

Network bandwidth is also becoming cheaper to deliver to users through home broadband connections and on their mobile devices. The combination or cheap bandwidth, increased network speeds, and high performance computer hardware opens up the possibility of distributed processing for faster results from computing large data sets. Distributed processing is used to divide large datasets into smaller, more manageable pieces in order to process them individually and produce results faster through the use of multiple machines connected over a network. It is the use of more than one processor to perform the processing for an individual task\cite{distributedprocessing}. Multiplayer games can utilize a network to run a game instance on high powered machines that will then send rendering information to the connected clients. MMORPG Massively Multiplayer Online Role Playing Games use the client/server architecture to manage thousands of users simultaneously while they are connected to remote servers running instances of the game. World of Warcraft\cite{worldofwarcraft} is an example fo a very popular MMORPG that efficiently utilizes available network bandwidth and the internet to deliver fast, reliable, and relatively bug free gameplay to thousands of players all over the world. Because artificial intelligence algorithm processing can be intensive, using a similar model to the client/server architecture used in multiplayer games to process large amounts of data on a higher end machine instead of the users device can free up the devices CPU processing time and allow it to allocate more to other processes.

What this project aims to achieve is the use of the internet as a means to transmit the results of executing CPU intensive path finding algorithms used in real time strategy games on a remote server machine to the client. Abstracting the implementations of path finding algorithms and providing developers with a simple to use Application Programming Interface that communicates with a remote server to generate results may save individually developers and studios a considerable amount of time, money, and resources. The A* pathfinding algorithm is a popular algorithm used in games to calculate paths through a games geometry. The graph consists of nodes and connections, also known as vertex and edges, with weights or values associated with each edge. Moving from one node to another node may incur a cost which is the value assigned to a connection. A* works on a non-negative weighted graph\cite[p.~198]{nonnegativeweightedgraph} and so the game geometry must be converted into a state that the algorithm can understand. This algorithm, once it receives the data it needs over the network, will process the data sending the result back to the client for use in the game. Many times in real time strategy games the player or enemy units will need to move from one location on the map to another along the shortest possible route while avoiding obstacles such as villages, cliffs, towers, or oceans. It would not be acceptable for the units to just cut across the map ignoring its explicit structure. The A* pathfinding algorithm has many different variations depending on specific use cases and available hardware for efficiencies. 

The implementation details for the client side API will be explained in detail in the section \ref{section:clientapidesign}. The API itself needs to be usable by game developers in an intuitive way in order to get the results that they need from the system and so will need to be designed with a focus on developers. The communication layer that will be used to transmit data between the client and the server will need to be efficient and reliable in order to deliver data that is complete and integral. Missing packets or corrupt data is unacceptable when accurate processing needs to be done by complex algorithms to produce results fast. Further, congestion on a network needs to be handled efficiently to prevent delays in communication between the client and server when requesting path data for in game entities. Large delays may annoy users of the system and can cause a bad gaming experience. This will be described in the section \ref{section:networklayer}. The server system that will communicate with each client to handle requests and schedule tasks for the Artificial Intelligence system will be discussed in section \ref{section:serverdesign}. The server system will need to communicate with clients concurrently, handling data I/O and managing a task record in order to efficiently service each client fairly. Efficiently allocating resources as needed and recovering from interrupted or terminated client communications will be the job of the server. Identifying each client and routing information is also necessary to ensure a good user experience. The AI module residing on the server that will communicate with the server system will be responsible for all algorithm management. This will be explained in section \ref{section:aimoduledesign}. Choosing the right implementation of an algorithm in order to achieve the best possible speed and efficiency will be key to producing fast and accurate results for the client games using the system. There are many different types of games that fall under the umbrella of Real Time Strategy. The AI module will attempt to service client requests that vary greatly from one another in the RTS genre of games in an effort to provide a generic solution to pathfinding that can be applied to many different situations.

\section{Problem Definition, Background, and Planning}

The problems faced by game developers when implementing Artificial Intelligence in their games depend on the type of AI needed for a particular problem they are facing. One of the problems that need to be addressed initially is the choice of whether to use a complex implementation of an algorithm to produce expected behavioural output data or to just use some nice animation effects to emulate smart entity characteristics. Another problem arises when the choice is made to use an algorithm to produce behavioural data; what is the best and most efficient way to implement the algorithm?. When it comes down to using an algorithm instead of some animation effects more problems surface such as finding a developer that is skilful enough to program efficiently but also possesses the knowledge to recognize whether a simple implementation will produce better results compared to a more complex and convoluted one. They must also know how to use the devices hardware architecture such as the CPUs cache memory to squeeze as much performance out of a device as possible if it is needed. 

Using a network creates another unique set of problems when it comes to transmitting data between clients or to a remote server. Network latency is delay and measures the time taken for data to travel from its source to its destination\cite{networklatency}. A developer can use a network to create a multiplayer game that allows multiple users to send data to each other or to a server so they can interact in a coherent and simulated game world. World of Warcraft\cite{worldofwarcraft} uses the internet to transmit data from a users game client to a central server. This data is used as input to a game instance that is running on the server and the results of the input are sent back to the client. The client will then use this data to update the rendering or physics engine for the local game world to reflect what is happening on the server game world. The time taken for data to travel must be extremely small, measured in milliseconds, in order to maintain a good QoS Quality of Service for the players.

For remote AI, similar considerations need to be adhered to when communicating over a network. The concept of using the network to transmit data will be similar but the redundant systems to improve the QoS will be different. For example, in multiplayer games a technique know as Client Side Prediction is used to instantly update the local game world while simultaneously sending coordinate data to the remote server. Predictions are made on the client to alleviate the effects of network latency creating lag when updating the players position in the game world. If there are discrepencies between the players position on the client and the players position after the server has calculated the inputs, the client is updated to reflect the server because the server has authority over the game world which reduces cheating. For remote AI, previous paths can be cached on the client side in order to reduce the processing time taken to calculate a path for an entity. The initial request can be sent to the server, the AI module generates a path and returns the information, it is then stored in case a similar query is made by the game client. This will reduce the dependency on the network to produce results and will improve QoS for the developers. 

\subsection{Objectives}

Explain how you understand the project objective(s), what is to be solved or done, your perception of what has to be accomplished including the scope. 

The objectives of the \textit{RAIG} project are to:

\begin{itemize}
\item{Design and develop a remote Artificial Intelligence service for game developers}
\item{Provide an Application Programming Interface that can be integrated into new and existing projects that will communicate with the remote AI service}
\item{Design and build a server system that can scale to multiple users efficiently without administration or extra work effort}
\item{Create a modular algorithm manager that can process Python3 source code to allow earier integration of algorithm implementations created by developers}
\end{itemize}

Creating a remote AI service that is easy to understand is a key component in the RAIG project. Developers need an easier alternative to implementing complex algorithms in their source code. Making the integration of the system seamless and straight forward will simplify the process by providing an intuitive API to build against without needing to worry about the implementation details. 

The API will provide developers with action functions that will be designed around a seperate entity structure. The developer will ask the service for solutions and get data in return that they can use in specific ways in their applications.

The server system will need to scale to users seamlessly. Allowing multiple users to connect and use the service concurrently is fundamental to the projects performance. The server must hold state on each connected client using persistent storage. It must also provide uninterrupted service to clients with a focus on realtime processing of user generated data and network communications. 

The server system is home to the AI manager system. This system must be capable of using developer written Python3 algorithm implementations. Ease of use and extensibilty is a key goal of the RAIG project and also allows for an open development community to form around algorithm implemenations and efficiencies which fosters education and growth. 

\subsection{Project Planning}
Agile approach, PID, Charter, Phases.

Provide a plan for the project timeline implementation including key tasks, deadlines and outputs.



\subsection{Revision History}

\subsubsection*{Version 0.1}

Initial draft of the project report contains most of the key headings related to research and the technologies being used in the project. 

\subsubsection*{Version 0.2}

Additions made to include implementation headings and areas that need to be included in the final report.

\subsubsection*{Version 0.3}


\section{Literature Review and Research}
Outline the literature reviewed and research completed to inform the completion of your project.  This should include commentary on current and emerging technologies/systems, key data, information, source, code etc. which was sourced as part of your research.  Where relevant indicate any conclusions or recommendations arising from your research

\subsection{Overview of Aritificial Intelligence in Games}

\subsubsection{Hardware Resources}

\subsubsection{Levels of Aritificial Intelligence}

\subsection{Networked Aritificial Intelligence}

\subsubsection{Distributed Client Side Processing}

\subsubsection{Central Server Architecture}

\subsection{Current Issues with Aritificial Intelligence in Games}

\subsubsection{Complex Algorithms \& Implementations}

\subsubsection{Network Latency}

\subsubsection{Human Perception}

\subsection{Conclusions of Research}

Explain the reasoning behind the decisions made for the client api, the sockets layer using TCP, the server application forking, and the AI system structure using C++ and Python.

\section{System Design and Configuration}
Describe your approach to solving the problem and, where relevant, include sub sections on

\subsection{System Architecture}

\subsection{Class Diagram}

\subsection{Sequence Diagram}

Actual code is to be provided on an accompanying and suitably labeled CD.

\section{Example of use}
How do you see the solution being used in practise? Illustrate as appropriate with User Stories / Use Cases 

\begin{figure}[H]
\begin{lstlisting}
const float TimeBetweenCameraChanges = 2.0f;
const float SmoothBlendTime = 0.75f;
TimeToNextCameraChange -= DeltaTime;
if (TimeToNextCameraChange <= 0.0f)
{
    TimeToNextCameraChange += TimeBetweenCameraChanges;

    // Find the actor that handles control for the local player.
    APlayerController* OurPlayerController = UGameplayStatics::GetPlayerController(this, 0);
    if (OurPlayerController)
    {
        if ((OurPlayerController->GetViewTarget() != CameraOne) && (CameraOne != nullptr))
        {
            // Cut instantly to camera one.
            OurPlayerController->SetViewTarget(CameraOne);
        }
        else if ((OurPlayerController->GetViewTarget() != CameraTwo) && (CameraTwo != nullptr))
        {
            // Blend smoothly to camera two.
            OurPlayerController->SetViewTargetWithBlend (CameraTwo, SmoothBlendTime);
        }
    }
}
\end{lstlisting}
	\caption{This is a code listing}
	\label{code:raig header file}
\end{figure}

And this is a reference to the code listing \ref{code:raig header file}


\begin{table}[H] %% <--- and this
\begin{center}

\begin{tabular}{ | c | c |}
\hline
A & B \\ 
\hline
C & D \\
\hline
\end{tabular}
\caption{Example table caption}
\label{table:x Example table}
\end{center}
\end{table}

This is a reference to table \ref{table:x Example table}

\begin{figure}[H]
	\centering
    	\includegraphics[width=\textwidth]{Figures/lit_logo}
	\caption{Picture of the LIT Logo}
	\label{fig:example figure and caption}
\end{figure}

And this is a reference to the figure in Figure \ref{fig:example figure and caption}.

\section{Remote Artificial Intelligence for Games}

\subsection{Introduction}

Describe how the solution was implemented and any problems particular to this stage.
Client side API\\
Sockets layer\\
Server side application\\
AI Algorithms\\

\subsubsection{Networking Model}

Client server model\\

\subsubsection{Design Patterns}
Observer pattern\\
Strategy pattern\\
Lazy loading\\
RAII\\

\subsection{Client API Design}
\label{section:clientapidesign}

The API should be designed with developers in mind and must be intuitive to use. If a developer wants a path from A to B on their map, the API must allow the developer to quiery the service and recieve the answer. While implementing the API the developer needs options or weights that may determine what path is choosen for a particular situation. 

\subsubsection{Pimpl Idiom}

The Pimpl idiom is a design pattern used to hide the implemenation details of an API. A pointer in the interface class of the API allows access to the implementation details defined in the associated .cpp file. The implemenation details can be compiled into a library and linked at runtime which abstracts the implementation details from the users. A pointer to an object defined inside the .cpp implementation file removes any of the declarations and includes needed for the API header file. This technique can be used with proprietary code and prevents users from casually reading the header file to find out how the system is coded. 

\begin{figure}[H]
\begin{lstlisting}
class Raig
{
public:
	Raig();
	~Raig();
	void connect(char* IpAddress);
private:
	class RaigImpl; 
	std::unique_ptr<RaigImpl> m_Impl;
};
\end{lstlisting}
	\caption{Pimpl idiom implementation in the client API header file}
	\label{code:pimplidiom}
\end{figure}



\subsubsection{Game Representation}

Custom structs constraining how the game will be presented to the AI


\subsection{BSD Sockets Layer}
\label{section:networklayer}

\subsubsection{UDP vs TCP}

\subsubsection{Communication Protocol}

Packet header overview and details.\\

\subsection{Server System Design}
\label{section:serverdesign}

There are many ways a server systems architecture can be designed. Multiple users may need to connect and use the services provided by the server at any one time. How the server will scale to the number of users is a very important consideration when designing a remote service. This decision needs to made early in the initial envisioning phase of a project becuase it determines how the resources of the host machine will be used, how to limit or allocate more resources if needed, and also the approach taken to implement the solution.\\

\subsubsection{Benefits of Remote Processing}

Moving the graph search and processing to the server is a huge benefit to game developers. It allows the developers to forget about how the AI algorithms will run on particular systems or how much time it may take to calculate a specific query. Graph processing for state based AI is an example of a CPU intensive task, when implemented well. Removing this processing to the server frees up the resources needed for the action so they can be used elsewhere.\\


\subsubsection{Fork or Select}

Two ways to handle multiple clients connecting to a server are to \textit{fork()} a new process for each client, or using the \textit{select()} function to listen for active file descriptors. Both methods have there advantages and limitations. Forking a process to handle a client request or using select to handle requests starts with creating a listening socket on the server. 

\begin{figure}[H]
\begin{lstlisting}
sock = socket(AF_INET, SOCK_STREAM, 0); 
if (sock < 0) {
	perror("creating stream socket");
	exit(1);
}

server.sin_family = AF_INET;
server.sin_addr.s_addr = htonl(INADDR_ANY);
server.sin_port = htons(HANGMAN_TCP_PORT);

if (bind(sock, (struct sockaddr *) &server, sizeof(server)) < 0) {
	perror("binding socket");
	exit(2);
}

listen(sock, 5);
\end{lstlisting}
	\caption{This is another code listing \cite{stevensunp}}
	\label{code:raig header source}
\end{figure}

The socket is created using the \textit{socket()} function, this returns a file descriptor which is an integer value identifying the socket on the system. The \textit{SOCK\_STREAM} argument is used to create a TCP streaming socket. Next the servers address structure is filled in with details pertaining to a passive server. The \textit{htonl(INADDR\_ANY)} function on line 8, tells the server to listen for any address, IP 0.0.0.0, in order to receive incoming connection requests from any IP address. The address structure is also initialized with a port number, shown on line 9 in code listing \ref{lst:server listen}. Using the \textit{bind()} function while passing in the socket file descriptor and address structure will bind the socket to the port.\\ 

This is similar to how a client socket is created and initialized. The main differences being that the active client will use the \textit{connect()} function to connect to a passive server and will also fill in an address structure with details of the server. The server on the other hand uses the \textit{listen()} function to passively listen for incoming client connections on the port number it is bound to. \\

Once the server is running and listening for incoming clients it can handle each client request by forking a process. Forking a process starts with a parent, this parent will create child processes that will execute along side the parent and will communicate with clients using the file descriptors associated with each. When a server accepts a connection is will \textit{fork()}, this will create another process that contains a copy of the data stored in the parent process, along with the newly created file descriptor for the conenction. The parent will then close the file descriptor it has which reduces the reference count to the descriptor by 1. The child process has a copy of this information and so the child can still use the file descriptor to send and receive data. Once the child process is finished with the client communications it closes the socket, reducing the reference count to 0, and exits. The parent must then kill the process in order to aviod creating \textit{zombie} processes that have been allocated system resources but are not being used. Killing a child process involves handling signals from the kernel in the parent that identify the child process being terminated. An advantage to using \textit{fork()} over \textit{select()} is that the process can handle each client individually and does not have to worry about any more incoming connections to the server. A disadvantage to forking is that it has to uses shared memory to communicate with other processes. This can introduce concurrency issues that can be very complex, difficult to understand, and hard to debug if something goes wrong.\\

Another approach to handling client connections is to use \textit{select()}. This method will not create new processes. A single process handles all open file descriptors by looping through them and processing any that are active. The advantages of this approach over forking is that all clients are handled by a single process. This removes the need for shared memory or synchronisation primitives in order to communicate with other processes.\cite{theworldofselect} The disadvantage to using \textit{select()} over forking is that it cannot act like there is only one client at a time. With \textit{fork()} the developer can program the server as if there is only ever going to be one client which makes the code alot less complex. 



In conclusion, handling multiple clients at the server can be achieved through a variety of different ways 

\subsubsection{Round Robin DNS}

Multiple servers running instances of the AI application that can handle a number of clients each. 

\subsection{Artificial Intelligence \& Algorithms}
\label{section:aimoduledesign}

\subsubsection{A* Path finding}

\subsubsection{Brute force}

\subsubsection{Graph Sturctures}

Game AI is best represented as a graph like structure. Using a graph allows many different algorithms to be used to process the data efficiently.

\subsection{Analysis, Testing, and Results}

Describe the testing that was carried out and the results.

Give an account of the results of the project, what was accomplished, what wasn't and the reasons why. If the project is incomplete or has potential for improvement state what further features could be included and how existing ones might be improved.

Google C++ testing framework

\subsection{Summary}


\section{User manual (where appropriate)}
Write a concise but complete user manual or guide. This can be light on text so long as a novice user has enough information to use the application unaided.

LaTeX\\
doxygen\\
Make\\
MetaUML\\
UMLet\\

\section{Critical analysis, Conclusions, and Future Work}

Evaluate the success of what was achieved against the original objectives. 

What difficulties were encountered and what lessons learned from the project? 

How well did the project follow the planned timeline and how useful was the timeline?  

What are your key conclusions from the work.?

This is a reference to the graph appendix \ref{appendix:graph}

This is a reference to the Network Programming Book \cite[p.~215]{stevensunp}

% References
\newpage

\begin{thebibliography}{99}
\addcontentsline{toc}{section}{References}

\bibitem{skynet}
Skynet (Terminator) - Wikipedia, the free encyclopedia. 2015. [ONLINE] Available at: \textit{https://en.wikipedia.org/wiki/Skynet\_(Terminator).} [Accessed 09 October 2015].

\bibitem{stevensunp}
W. Richard Stevens, 2003. \textit{Unix Network Programming, Volume 1: The Sockets Networking API (3rd Edition)}. 3 Edition. Addison-Wesley Professional.

\bibitem{theworldofselect}
The World of select(). 2015. The World of select(). [ONLINE] \\
Available at: \textit{http://www.lowtek.com/sockets/select.html.} [Accessed 01 October 2015].

\bibitem{nonnegativeweightedgraph}
Ian Millington, 2009. \textit{Artificial Intelligence for Games}. 2 Edition. CRC Press.

\bibitem{distributedprocessing}
Distributed Processing . 2015. Distributed Processing . [ONLINE] Available at: \textit{http://docs.oracle.com/cd/A87860\_01/doc/server.817/a76965/c29dstpr.htm}. [Accessed 10 October 2015].

\bibitem{worldofwarcraft}
World of Warcraft - Wikipedia, the free encyclopedia. 2015. World of Warcraft - Wikipedia, the free encyclopedia. [ONLINE] Available at: \textit{https://en.wikipedia.org/wiki/World\_of\_Warcraft}. [Accessed 10 October 2015].

\bibitem{networklatency}
HTG Explains: How Latency Can Make Even Fast Internet Connections Feel Slow. 2015. [ONLINE] Available at: \textit{http://www.howtogeek.com/138771/htg-explains-how-latency-can-make-even-fast-internet-connections-feel-slow/.} [Accessed 10 October 2015].

\end{thebibliography}



% Appendices
\newpage
\begin{appendices}

\section{Graph Appendix}
\label{appendix:graph}
This is the graph appendix...

\section{Another Appendix}

\end{appendices}

\end{document}